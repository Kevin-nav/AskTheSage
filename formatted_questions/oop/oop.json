[
  {
    "question_text": "What is the output of the following code involving a class variable modification?\\n```python\nclass Test:\n    x = 10\n\nt1 = Test()\nt2 = Test()\nt1.x = 20\n\nprint(Test.x, t1.x, t2.x)\n```",
    "options": [
      "10 20 10",
      "20 20 20",
      "10 20 20",
      "10 10 10"
    ],
    "correct_answer_index": 0,
    "explanation": "When `t1.x = 20` is executed, it creates a new *instance* attribute `x` for `t1` that shadows the class attribute. `Test.x` remains unchanged, and `t2.x` still accesses the original class attribute. Therefore, the output is the class attribute (10), t1's instance attribute (20), and t2's access to the class attribute (10).",
    "has_latex": true,
    "difficulty_score": 3.24
  },
  {
    "question_text": "Which special method is implicitly called when using the `in` keyword to check for membership, e.g., `if 'a' in my_object:`?",
    "options": [
      "`__in__`",
      "`__hasitem__`",
      "`__contains__`",
      "`__member__`"
    ],
    "correct_answer_index": 2,
    "explanation": "The `in` operator is overloaded by the `__contains__(self, item)` special method. It should return `True` if `item` is in `self`, and `False` otherwise.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "What does the `@property` decorator allow you to do?",
    "options": [
      "Create a read-only attribute.",
      "Define a method that can be accessed like an attribute (without parentheses).",
      "Make an attribute private.",
      "Define a method that can only be called from within the class."
    ],
    "correct_answer_index": 1,
    "explanation": "The `@property` decorator is used to create 'getter' methods. It allows a method to be accessed as if it were a regular attribute, hiding the method call syntax and allowing for computations or logic to be executed on access.",
    "has_latex": false,
    "difficulty_score": 2.4
  },
  {
    "question_text": "Consider the following code. What is the correct way to change the temperature to 32 degrees Celsius?\\n```python\nclass Temperature:\n    def __init__(self, celsius):\n        self._celsius = celsius\n\n    @property\n    def fahrenheit(self):\n        return self._celsius * 9/5 + 32\n\ntemp = Temperature(30)\n```",
    "options": [
      "`temp.fahrenheit = 89.6`",
      "`temp.celsius = 32`",
      "`temp._celsius = 32`",
      "It cannot be changed because `fahrenheit` is a read-only property."
    ],
    "correct_answer_index": 2,
    "explanation": "The code only defines a 'getter' for the `fahrenheit` property, making it read-only. To change the temperature, you must modify the underlying `_celsius` attribute directly. A more robust solution would involve defining a `@fahrenheit.setter`.",
    "has_latex": true,
    "difficulty_score": 3.0
  },
  {
    "question_text": "If `B` inherits from `A`, and `C` inherits from `B`, and all three classes define a method named `run()`, what will `super().run()` do when called from within `C`'s `run()` method?",
    "options": [
      "It will call `A.run()`.",
      "It will call `B.run()`.",
      "It will cause a `RecursionError`.",
      "It will cause a `SyntaxError`."
    ],
    "correct_answer_index": 1,
    "explanation": "`super()` in class `C` will look up the Method Resolution Order (MRO) for `C` and call the `run` method from the next class in the chain, which is its direct parent, `B`.",
    "has_latex": false,
    "difficulty_score": 2.16
  },
  {
    "question_text": "What is the 'diamond problem' in multiple inheritance?",
    "options": [
      "When a class inherits from four parent classes.",
      "When two classes inherit from the same parent, and another class inherits from both of them, creating ambiguity in method resolution.",
      "A performance issue caused by deep inheritance chains.",
      "A problem related to inheriting private attributes."
    ],
    "correct_answer_index": 1,
    "explanation": "The diamond problem occurs when a class (D) inherits from two classes (B and C) that both inherit from a single superclass (A). If a method in A is overridden by both B and C, it's ambiguous which version D should inherit. Python's MRO solves this deterministically.",
    "has_latex": false,
    "difficulty_score": 3.6
  },
  {
    "question_text": "True or False: A class that inherits from another class is called a 'base class'.",
    "options": [
      "True",
      "False"
    ],
    "correct_answer_index": 1,
    "explanation": "False. The class that is being inherited from is the 'base class' or 'superclass'. The class that does the inheriting is the 'derived class' or 'subclass'.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "What will the following code print?\\n```python\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\n    def __eq__(self, other):\n        return self.name == other.name\n\np1 = Person(\"Alice\")\np2 = Person(\"Alice\")\np3 = p1\n\nprint(p1 == p2, p1 is p3)\n```",
    "options": [
      "False True",
      "True True",
      "True False",
      "False False"
    ],
    "correct_answer_index": 1,
    "explanation": "The `==` operator calls the `__eq__` method, which compares the `name` attributes, so `p1 == p2` is `True`. The `is` operator checks for object identity (if they are the same object in memory). Since `p3` is an alias for `p1`, `p1 is p3` is also `True`.",
    "has_latex": true,
    "difficulty_score": 3.24
  },
  {
    "question_text": "Which pair of special methods is essential for creating a class that acts as a context manager (used with the `with` statement)?",
    "options": [
      "`__init__` and `__del__`",
      "`__enter__` and `__exit__`",
      "`__start__` and `__stop__`",
      "`__open__` and `__close__`"
    ],
    "correct_answer_index": 1,
    "explanation": "The `with` statement protocol is defined by the `__enter__` and `__exit__` methods. `__enter__` is called at the beginning of the `with` block for setup, and `__exit__` is called at the end for cleanup, even if exceptions occur.",
    "has_latex": false,
    "difficulty_score": 2.4
  },
  {
    "question_text": "An abstract method defined in an Abstract Base Class (ABC) can have an implementation.",
    "options": [
      "True",
      "False"
    ],
    "correct_answer_index": 0,
    "explanation": "True. An abstract method can have an implementation. Subclasses can then use `super()` to call this implementation while still being required to provide their own override.",
    "has_latex": false,
    "difficulty_score": 3.0
  },
  {
    "question_text": "What is the purpose of the `__del__` special method (destructor)?",
    "options": [
      "To explicitly delete an object from memory.",
      "To be called by the `del` keyword.",
      "To perform cleanup actions just before an object is garbage collected.",
      "To prevent an object from being deleted."
    ],
    "correct_answer_index": 2,
    "explanation": "`__del__` is not called by `del obj` (that just decrements the reference count). It is called by Python's garbage collector when an object's reference count reaches zero, allowing for final cleanup like closing files or network connections.",
    "has_latex": false,
    "difficulty_score": 3.6
  },
  {
    "question_text": "What happens if an exception is raised inside a `with` block?",
    "options": [
      "The program crashes immediately, and `__exit__` is not called.",
      "The `__exit__` method is called with details about the exception, and then the exception is re-raised unless `__exit__` returns `True`.",
      "The `__exit__` method is skipped, and the exception propagates.",
      "The `__enter__` method is called a second time to handle the error."
    ],
    "correct_answer_index": 1,
    "explanation": "The `__exit__(self, exc_type, exc_value, traceback)` method is always called. If an exception occurred, its details are passed as arguments. This allows the context manager to clean up resources properly. If `__exit__` returns a truthy value, the exception is suppressed.",
    "has_latex": false,
    "difficulty_score": 3.75
  },
  {
    "question_text": "Which of the following best describes the principle of 'Composition over Inheritance'?",
    "options": [
      "It's always better to use inheritance than composition.",
      "Favor creating complex objects by including instances of other classes (has-a relationship) rather than inheriting from them (is-a relationship).",
      "Composition is a type of inheritance.",
      "Inheritance is more flexible than composition."
    ],
    "correct_answer_index": 1,
    "explanation": "This design principle suggests that you should favor flexibility. Composition (where a class contains an instance of another class) often leads to more flexible and decoupled designs than rigid inheritance hierarchies.",
    "has_latex": false,
    "difficulty_score": 3.0
  },
  {
    "question_text": "What will be the output?\\n```python\nclass A:\n    def run(self):\n        return \"A\"\nclass B(A):\n    def run(self):\n        return \"B\"\nclass C(A):\n    def run(self):\n        return \"C\"\nclass D(B, C):\n    pass\n\nd = D()\nprint(d.run())\n```",
    "options": [
      "A",
      "B",
      "C",
      "TypeError due to ambiguity"
    ],
    "correct_answer_index": 1,
    "explanation": "This demonstrates the 'diamond problem'. Python's MRO for class D is `(D, B, C, A, object)`. When `d.run()` is called, Python searches this list and finds `run` in class B first, so it executes `B.run()` and stops searching.",
    "has_latex": true,
    "difficulty_score": 3.6
  },
  {
    "question_text": "To allow assignment to an object's items using square bracket notation (e.g., `obj[key] = value`), which method must be implemented?",
    "options": [
      "`__getitem__`",
      "`__setitem__`",
      "`__assign__`",
      "`__delitem__`"
    ],
    "correct_answer_index": 1,
    "explanation": "The `__setitem__(self, key, value)` special method is called when you use square bracket assignment. It is the counterpart to `__getitem__`.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "A class that does not have an `__init__` method...",
    "options": [
      "cannot be instantiated.",
      "will raise a `SyntaxError`.",
      "implicitly uses the `__init__` method from its parent class if it exists, or a default object constructor if it doesn't.",
      "must only have static methods."
    ],
    "correct_answer_index": 2,
    "explanation": "If a class does not define its own constructor, Python will look up the inheritance chain for one to use. If no parent has an `__init__`, a default empty constructor from the base `object` class is used, which does nothing.",
    "has_latex": false,
    "difficulty_score": 2.16
  },
  {
    "question_text": "What is the purpose of `isinstance(obj, ClassName)`?",
    "options": [
      "To check if `obj` is the same object in memory as `ClassName`.",
      "To check if `obj` is an instance of `ClassName` or an instance of a subclass of `ClassName`.",
      "To check if `obj` is an instance of `ClassName` only (and not a subclass).",
      "To convert `obj` into an instance of `ClassName`."
    ],
    "correct_answer_index": 1,
    "explanation": "`isinstance()` is the recommended way to check an object's type, as it correctly handles inheritance. It returns `True` if the object's type is the specified class or any of its derived classes.",
    "has_latex": false,
    "difficulty_score": 1.44
  },
  {
    "question_text": "What is the output of this code?\\n```python\nclass Parent:\n    def __init__(self):\n        self.value = 5\n\nclass Child(Parent):\n    def __init__(self):\n        self.value = 10\n\nc = Child()\nprint(c.value)\n```",
    "options": [
      "5",
      "10",
      "AttributeError",
      "The code has an error because `super()` is not called."
    ],
    "correct_answer_index": 1,
    "explanation": "The `Child` class overrides the `__init__` method completely. It does not call the parent's constructor. Therefore, only `self.value = 10` is executed, and the value 5 is never assigned.",
    "has_latex": true,
    "difficulty_score": 1.8
  },
  {
    "question_text": "Which magic method would you implement to make your object support the less than operator `<`?",
    "options": [
      "`__le__`",
      "`__gt__`",
      "`__lt__`",
      "`__less__`"
    ],
    "correct_answer_index": 2,
    "explanation": "The `__lt__(self, other)` method implements the less-than comparison (`<`). Similarly, `__le__` is for `<=`, `__gt__` is for `>`, and `__ge__` is for `>=`.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "What is the output of the following code snippet?\\n```python\nclass Chain:\n    def __init__(self, value):\n        self.value = value\n        \n    def __getattr__(self, name):\n        return f\"No such attribute: {name}\"\n\nc = Chain(5)\nprint(c.value)\nprint(c.non_existent)\n```",
    "options": [
      "5\\nNo such attribute: non_existent",
      "5\\nAttributeError",
      "AttributeError",
      "5\\nNone"
    ],
    "correct_answer_index": 0,
    "explanation": "`__getattr__` is a special method that is called only when a requested attribute is not found in the usual places (instance, class, parents). Accessing `c.value` finds the attribute normally. Accessing `c.non_existent` fails, triggering `__getattr__`.",
    "has_latex": true,
    "difficulty_score": 3.75
  },
  {
    "question_text": "The procedural programming paradigm organizes programs around...",
    "options": [
      "objects and data.",
      "functions or blocks of statements that manipulate data.",
      "events and event handlers.",
      "class hierarchies."
    ],
    "correct_answer_index": 1,
    "explanation": "Procedural programming is based on the concept of the procedure call. Programs are structured as a series of procedures (functions or subroutines) that perform computations on data.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "Which of these is NOT a direct benefit of inheritance?",
    "options": [
      "Code Reusability",
      "Data Hiding",
      "Logical Hierarchy Modeling",
      "Extensibility"
    ],
    "correct_answer_index": 1,
    "explanation": "Data Hiding is a direct benefit of Encapsulation, not Inheritance. Inheritance is primarily about reusing code, establishing 'is-a' relationships, and extending functionality.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "In a `Hybrid Inheritance` scenario, a class `D` inherits from `B` and `C`. Class `B` inherits from `A`. Class `C` has no parent. This is a mix of which two inheritance types?",
    "options": [
      "Single and Multiple",
      "Multilevel and Multiple",
      "Hierarchical and Single",
      "Multilevel and Hierarchical"
    ],
    "correct_answer_index": 1,
    "explanation": "The chain `A -> B -> D` involves Multilevel inheritance. The fact that `D` inherits from two parents (`B` and `C`) makes it Multiple inheritance. Therefore, it is a hybrid of Multilevel and Multiple inheritance.",
    "has_latex": false,
    "difficulty_score": 3.0
  },
  {
    "question_text": "Which magic method must return an integer?",
    "options": [
      "`__str__`",
      "`__repr__`",
      "`__len__`",
      "`__call__`"
    ],
    "correct_answer_index": 2,
    "explanation": "The `__len__` method is expected to return a non-negative integer representing the length or size of the object. Returning another type will result in a `TypeError` when `len()` is called.",
    "has_latex": false,
    "difficulty_score": 1.5
  },
  {
    "question_text": "What is the output?\\n```python\nclass Wallet:\n    def __init__(self, amount):\n        self.amount = amount\n\n    def __bool__(self):\n        return self.amount > 0\n\nw1 = Wallet(50)\nw2 = Wallet(0)\n\nif w1:\n    print(\"w1 is True\")\nif not w2:\n    print(\"w2 is False\")\n```",
    "options": [
      "w1 is True",
      "w2 is False",
      "w1 is True\\nw2 is False",
      "The code produces an error."
    ],
    "correct_answer_index": 2,
    "explanation": "The `__bool__` method defines the truthiness of an object. For `w1`, `50 > 0` is `True`, so the first `if` block executes. For `w2`, `0 > 0` is `False`, so the `if not w2` condition is met and the second block executes.",
    "has_latex": true,
    "difficulty_score": 2.7
  },
  {
    "question_text": "If a class has no `__bool__` method, how does Python determine its truthiness in an `if` statement?",
    "options": [
      "It always defaults to `True`.",
      "It always defaults to `False`.",
      "It checks for a `__len__` method. If it returns 0, the object is `False`, otherwise `True`.",
      "It raises a `TypeError`."
    ],
    "correct_answer_index": 2,
    "explanation": "If `__bool__` is not defined, Python falls back to checking for `__len__`. If `__len__` is defined and returns zero, the object is considered `False`. If it returns a non-zero number, the object is `True`. If neither method is defined, instances are always considered `True`.",
    "has_latex": false,
    "difficulty_score": 3.6
  },
  {
    "question_text": "You have a `Student` class and a `Course` class. A `Student` can enroll in multiple `Course`s. This relationship is best modeled using:",
    "options": [
      "Inheritance, where `Student` inherits from `Course`.",
      "Inheritance, where `Course` inherits from `Student`.",
      "Composition, where the `Student` object contains a list of `Course` objects.",
      "A static method that links them."
    ],
    "correct_answer_index": 2,
    "explanation": "This is a classic 'has-a' relationship, not an 'is-a' relationship. A Student is not a type of Course. Therefore, composition is the appropriate design pattern. The `Student` class would have an attribute, like `self.courses`, which would be a list of `Course` instances.",
    "has_latex": false,
    "difficulty_score": 3.0
  },
  {
    "question_text": "What will `issubclass(bool, int)` return?",
    "options": [
      "True",
      "False",
      "TypeError",
      "None"
    ],
    "correct_answer_index": 0,
    "explanation": "This is a surprising fact of Python's type hierarchy. The `bool` type is actually a subclass of the `int` type, where `False` is equivalent to `0` and `True` is equivalent to `1`.",
    "has_latex": false,
    "difficulty_score": 3.75
  },
  {
    "question_text": "In Python, methods in a class that are not special methods and do not have a leading underscore are by default...",
    "options": [
      "public",
      "private",
      "protected",
      "static"
    ],
    "correct_answer_index": 0,
    "explanation": "Unlike languages like Java or C++, Python does not have strict access modifiers. By default, all methods and attributes are public and can be accessed from anywhere.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "Consider the code: `my_list = [1, 2, 3]`. In OOP terms, `my_list` is a(n) ________ of the `list` ________.",
    "options": [
      "class, object",
      "object, attribute",
      "instance, class",
      "method, class"
    ],
    "correct_answer_index": 2,
    "explanation": "In Python, everything is an object. `my_list` is a specific object, or instance, created from the `list` class blueprint.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "What is the output of the code below?\\n```python\nclass A:\n   pass\nclass B(A):\n   pass\n\nprint(issubclass(A, B))\n```",
    "options": [
      "True",
      "False",
      "None",
      "Error"
    ],
    "correct_answer_index": 1,
    "explanation": "`issubclass(sub, super)` checks if `sub` is a subclass of `super`. Here, `B` is a subclass of `A`, but `A` is not a subclass of `B`. Therefore, it returns `False`.",
    "has_latex": true,
    "difficulty_score": 1.44
  },
  {
    "question_text": "Which of the following creates a class `Car` that inherits from a class `Vehicle`?",
    "options": [
      "`class Car(inherits=Vehicle):`",
      "`class Car extends Vehicle:`",
      "`class Car(Vehicle):`",
      "`class Car: inherits Vehicle`"
    ],
    "correct_answer_index": 2,
    "explanation": "The correct syntax for inheritance in Python is to place the name of the parent class (or classes) inside parentheses after the child class name.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "If you have an object `emp` of class `Employee`, how would you check if it has an attribute named 'salary' before accessing it to avoid an `AttributeError`?",
    "options": [
      "`if emp.has('salary'):`",
      "`if hasattr(emp, 'salary'):`",
      "`if 'salary' in emp:`",
      "`if emp.exists('salary'):`"
    ],
    "correct_answer_index": 1,
    "explanation": "The built-in function `hasattr(object, name)` is the standard and safest way to check for the existence of an attribute before trying to access it.",
    "has_latex": false,
    "difficulty_score": 1.5
  },
  {
    "question_text": "What does the `pass` statement do within a class definition?",
    "options": [
      "It makes the class abstract.",
      "It ends the program.",
      "It acts as a placeholder, allowing for an empty class body without causing a `SyntaxError`.",
      "It makes all methods in the class private."
    ],
    "correct_answer_index": 2,
    "explanation": "`pass` is a null operation. It is used when a statement is syntactically required but you do not want any command or code to execute. It's often used for empty classes or functions as a placeholder.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "What will happen when this code is executed?\\n```python\nclass Math:\n    @staticmethod\n    def add(x, y):\n        return self.x + self.y\n\nprint(Math.add(2, 3))\n```",
    "options": [
      "5",
      "0",
      "An error because `self` is not defined in a static method.",
      "An error because static methods cannot have parameters."
    ],
    "correct_answer_index": 2,
    "explanation": "Static methods do not receive `self` as a parameter. Trying to access `self.x` or `self.y` inside `add` will raise a `NameError` because `self` has not been defined in the method's scope.",
    "has_latex": true,
    "difficulty_score": 2.7
  },
  {
    "question_text": "True or False: An abstract class can be instantiated.",
    "options": [
      "True",
      "False"
    ],
    "correct_answer_index": 1,
    "explanation": "False. The purpose of an abstract class is to serve as a blueprint for other classes. Python raises a `TypeError` if you attempt to create an instance of a class that contains one or more abstract methods that have not been implemented.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "You want to define a custom object that can be used in a `for` loop. Which special method must you implement?",
    "options": [
      "`__next__`",
      "`__loop__`",
      "`__iter__`",
      "`__for__`"
    ],
    "correct_answer_index": 2,
    "explanation": "To make an object iterable (usable in a `for` loop), it must implement the `__iter__` method. This method should return an iterator object, which in turn must have a `__next__` method.",
    "has_latex": false,
    "difficulty_score": 2.4
  },
  {
    "question_text": "Which is a key advantage of polymorphism in software design?",
    "options": [
      "It guarantees faster execution speed.",
      "It allows for writing generic, decoupled code that can work with new object types without modification.",
      "It simplifies debugging by making all objects behave identically.",
      "It reduces the memory footprint of a program."
    ],
    "correct_answer_index": 1,
    "explanation": "Polymorphism allows functions to be written to handle a general category of objects. As long as a new object type provides the required methods (interface), it can be used by that generic function without needing to rewrite the function itself. This promotes loose coupling and extensibility.",
    "has_latex": false,
    "difficulty_score": 2.4
  },
  {
    "question_text": "Which special method is used to get the number of items in a container?",
    "options": [
      "`__size__`",
      "`__count__`",
      "`__len__`",
      "`__length__`"
    ],
    "correct_answer_index": 2,
    "explanation": "The `len()` built-in function works by calling the `__len__` method of the object passed to it. This method should return the size of the container as an integer.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "What is the primary difference between a class attribute and an instance attribute?",
    "options": [
      "Class attributes are defined inside the `__init__` method, while instance attributes are defined outside.",
      "Class attributes are shared by all instances of a class, while instance attributes are unique to each instance.",
      "Class attributes can only be of string type, while instance attributes can be any type.",
      "Class attributes are immutable, while instance attributes are mutable."
    ],
    "correct_answer_index": 1,
    "explanation": "A class attribute is defined directly under the class declaration and is shared among all objects of that class. An instance attribute is typically defined inside the constructor (`__init__`) using `self` and is specific to each object.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "What will be the output of the following code?\\n```python\nclass Dog:\n    species = \"Canis familiaris\"\n\ndog1 = Dog()\ndog2 = Dog()\n\nDog.species = \"Canis lupus\"\n\nprint(dog1.species, dog2.species)\n```",
    "options": [
      "Canis familiaris Canis familiaris",
      "Canis familiaris Canis lupus",
      "Canis lupus Canis lupus",
      "AttributeError"
    ],
    "correct_answer_index": 2,
    "explanation": "The `species` attribute is a class attribute. Modifying it through the class (`Dog.species`) changes the value for all instances that haven't overridden it. Both `dog1` and `dog2` still refer to the shared class attribute.",
    "has_latex": true,
    "difficulty_score": 2.16
  },
  {
    "question_text": "In the context of OOP, what does the term 'state' refer to?",
    "options": [
      "The methods defined within a class.",
      "The current values of an object's attributes.",
      "The physical memory location of an object.",
      "Whether a class is abstract or concrete."
    ],
    "correct_answer_index": 1,
    "explanation": "The 'state' of an object is represented by the data it holds at any given moment, which corresponds to the current values of its instance attributes.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "Which of the following is the correct way to define a method that can be called on the class itself, rather than on an instance?",
    "options": [
      "A regular method defined with `def method_name(self):`",
      "A method decorated with `@staticmethod`",
      "A method decorated with `@classmethod`",
      "A global function defined outside the class"
    ],
    "correct_answer_index": 2,
    "explanation": "The `@classmethod` decorator is used to define a method that receives the class as its first argument (conventionally named `cls`) instead of the instance.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "What will be printed by the following code?\\n```python\nclass Counter:\n    count = 0\n    def __init__(self):\n        self.count += 1\n\nc1 = Counter()\nc2 = Counter()\nprint(c2.count)\n```",
    "options": [
      "0",
      "1",
      "2",
      "AttributeError"
    ],
    "correct_answer_index": 1,
    "explanation": "Inside `__init__`, `self.count += 1` creates a new *instance* attribute named `count` that shadows the class attribute. It initializes this instance attribute to `0 + 1 = 1`. Each instance will have its own `count` attribute with a value of 1.",
    "has_latex": true,
    "difficulty_score": 3.24
  },
  {
    "question_text": "What is the purpose of a static method, declared with `@staticmethod`?",
    "options": [
      "To modify the state of a specific instance.",
      "To modify the state of the class.",
      "To provide utility functionality related to the class, but independent of instance or class state.",
      "To ensure a method can only be called once."
    ],
    "correct_answer_index": 2,
    "explanation": "A static method does not receive an implicit first argument (`self` or `cls`). It's essentially a regular function namespaced within the class, used for tasks that relate to the class but don't depend on its state.",
    "has_latex": false,
    "difficulty_score": 2.4
  },
  {
    "question_text": "A method should be defined as a `classmethod` if it needs to...",
    "options": [
      "access instance-specific data.",
      "perform a calculation that does not use any class or instance data.",
      "access or modify class-level attributes, or act as a factory for creating instances.",
      "be inherited by a subclass."
    ],
    "correct_answer_index": 2,
    "explanation": "Class methods are primarily used when the method needs to work with the class itself, such as accessing class variables or creating instances of the class using alternative constructors.",
    "has_latex": false,
    "difficulty_score": 2.4
  },
  {
    "question_text": "What is the output of this code snippet?\\n```python\nclass MyClass:\n    @staticmethod\n    def add(a, b):\n        return a + b\n\nprint(MyClass.add(5, 3))\n```",
    "options": [
      "An error because `self` is missing",
      "An error because the method is called on the class",
      "8",
      "None"
    ],
    "correct_answer_index": 2,
    "explanation": "Static methods can be called directly on the class without creating an instance. They behave like regular functions namespaced within the class.",
    "has_latex": true,
    "difficulty_score": 1.8
  },
  {
    "question_text": "True or False: In Python, a subclass can inherit from multiple superclasses.",
    "options": [
      "True",
      "False"
    ],
    "correct_answer_index": 0,
    "explanation": "True. Python supports multiple inheritance, allowing a class to derive attributes and methods from several parent classes by listing them in parentheses: `class Child(Parent1, Parent2):`.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "What is Method Resolution Order (MRO) in Python?",
    "options": [
      "The order in which methods are written in a class.",
      "A rule that specifies which version of a method to execute in a multiple inheritance scenario.",
      "A tool for refactoring method names.",
      "The order in which `__init__` calls other methods."
    ],
    "correct_answer_index": 1,
    "explanation": "MRO is the algorithm Python uses to determine the sequence of classes to search when looking for a method. It is crucial in multiple inheritance to resolve which parent's method should be called.",
    "has_latex": false,
    "difficulty_score": 2.4
  },
  {
    "question_text": "Consider the following multilevel inheritance. What will be the output?\\n```python\nclass Grandparent:\n    def speak(self):\n        print(\"Grandparent speaking\")\n\nclass Parent(Grandparent):\n    def speak(self):\n        print(\"Parent speaking\")\n\nclass Child(Parent):\n    pass\n\nc = Child()\nc.speak()\n```",
    "options": [
      "Grandparent speaking",
      "Parent speaking",
      "An error because `Child` has no `speak` method",
      "Nothing is printed"
    ],
    "correct_answer_index": 1,
    "explanation": "The `Child` class inherits from `Parent`. When `c.speak()` is called, Python searches `Child` first, finds no `speak` method, then searches its parent, `Parent`. It finds `speak` in the `Parent` class and executes it.",
    "has_latex": true,
    "difficulty_score": 2.16
  },
  {
    "question_text": "What is the primary purpose of the `super()` function?",
    "options": [
      "To create an instance of the superclass.",
      "To refer to the parent class, allowing access to its methods from a subclass.",
      "To check if a class is a superclass of another.",
      "To delete a method from the superclass."
    ],
    "correct_answer_index": 1,
    "explanation": "`super()` returns a temporary proxy object that allows you to call methods of a superclass. It's commonly used to call the parent's `__init__` or to extend the functionality of an overridden method.",
    "has_latex": false,
    "difficulty_score": 1.44
  },
  {
    "question_text": "A child class defines an `__init__` method but does not call `super().__init__()`. The parent class also has an `__init__` method that sets an attribute `self.name`. What happens when an instance of the child class tries to access `self.name`?",
    "options": [
      "It will access the `name` attribute from the parent class without issue.",
      "It will raise an `AttributeError`.",
      "It will raise a `TypeError`.",
      "The child's `__init__` will automatically call the parent's `__init__`."
    ],
    "correct_answer_index": 1,
    "explanation": "If a child class defines its own `__init__`, it overrides the parent's. If `super().__init__()` is not called, the parent's constructor never runs, and the `self.name` attribute is never created for the child instance, resulting in an `AttributeError`.",
    "has_latex": false,
    "difficulty_score": 3.6
  },
  {
    "question_text": "What is the term for hiding an object's internal data and only allowing access through public methods?",
    "options": [
      "Inheritance",
      "Polymorphism",
      "Abstraction",
      "Encapsulation"
    ],
    "correct_answer_index": 3,
    "explanation": "Encapsulation is the bundling of data (attributes) and methods that operate on the data into a single unit (a class), and restricting direct access to some of the object's components.",
    "has_latex": false,
    "difficulty_score": 1.44
  },
  {
    "question_text": "How do you conventionally indicate that an attribute is 'protected' in Python?",
    "options": [
      "With no prefix (e.g., `my_var`)",
      "With a single leading underscore (e.g., `_my_var`)",
      "With a double leading underscore (e.g., `__my_var`)",
      "With the `protected` keyword."
    ],
    "correct_answer_index": 1,
    "explanation": "A single leading underscore is a convention to signal to other developers that an attribute or method is intended for internal use and should not be accessed directly from outside the class hierarchy.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "What mechanism does Python use to enforce 'private' attributes (those with a double underscore prefix)?",
    "options": [
      "It raises a `PermissionError` on access.",
      "It encrypts the attribute's value.",
      "It performs name mangling.",
      "It makes the attribute read-only."
    ],
    "correct_answer_index": 2,
    "explanation": "Python automatically renames attributes with a double underscore prefix to `_ClassName__attributeName`. This process, called name mangling, makes it harder to accidentally access or override the attribute from outside the class.",
    "has_latex": false,
    "difficulty_score": 2.4
  },
  {
    "question_text": "What will be the output of this code?\\n```python\nclass MyClass:\n    def __init__(self):\n        self.__private_var = 42\n\nobj = MyClass()\ntry:\n    print(obj.__private_var)\nexcept AttributeError:\n    print(\"Error\")\n```",
    "options": [
      "42",
      "Error",
      "None",
      "A SyntaxError occurs"
    ],
    "correct_answer_index": 1,
    "explanation": "Because of name mangling, the attribute `__private_var` is renamed to `_MyClass__private_var`. Attempting to access `obj.__private_var` directly will fail with an `AttributeError`.",
    "has_latex": true,
    "difficulty_score": 2.16
  },
  {
    "question_text": "Which OOP concept focuses on hiding complex implementation details and exposing only the essential features of an object?",
    "options": [
      "Encapsulation",
      "Inheritance",
      "Abstraction",
      "Composition"
    ],
    "correct_answer_index": 2,
    "explanation": "Abstraction is the principle of simplifying complex systems by modeling classes appropriate to the problem and hiding the intricate implementation details from the user.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "What happens if you try to create an instance of a class that inherits from `ABC` and has not implemented all of its parent's abstract methods?",
    "options": [
      "The program runs, but the unimplemented methods will do nothing.",
      "A `SyntaxError` is raised.",
      "A `TypeError` is raised.",
      "An `AttributeError` is raised."
    ],
    "correct_answer_index": 2,
    "explanation": "Python prevents the instantiation of any class that has not provided concrete implementations for all abstract methods inherited from its superclasses, raising a `TypeError`.",
    "has_latex": false,
    "difficulty_score": 3.0
  },
  {
    "question_text": "Which decorator is used to declare a method that must be implemented by subclasses?",
    "options": [
      "`@classmethod`",
      "`@staticmethod`",
      "`@abstractmethod`",
      "`@property`"
    ],
    "correct_answer_index": 2,
    "explanation": "The `@abstractmethod` decorator, used in a class that inherits from `ABC`, marks a method as abstract, requiring any concrete subclass to provide an implementation for it.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "The ability of different objects to respond to the same method call in different, specific ways is known as:",
    "options": [
      "Inheritance",
      "Polymorphism",
      "Encapsulation",
      "Abstraction"
    ],
    "correct_answer_index": 1,
    "explanation": "Polymorphism (meaning 'many forms') allows objects of different classes to be treated through a common interface. A single method call can invoke different behaviors depending on the object's type.",
    "has_latex": false,
    "difficulty_score": 1.44
  },
  {
    "question_text": "What concept is demonstrated by the `len()` function working on strings, lists, and dictionaries?",
    "options": [
      "Inheritance",
      "Encapsulation",
      "Operator Overloading",
      "Polymorphism (specifically, ad-hoc polymorphism)"
    ],
    "correct_answer_index": 3,
    "explanation": "The `len()` function behaves differently depending on the type of object it is called with. This is a form of polymorphism. Internally, it works by calling the object's `__len__` method.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "What is the primary difference between the `__str__` and `__repr__` special methods?",
    "options": [
      "`__str__` is for developers, `__repr__` is for end-users.",
      "`__str__` should return a user-friendly, readable representation, while `__repr__` should return an unambiguous, official representation used for debugging.",
      "`__str__` is called by `print()`, `__repr__` is never called automatically.",
      "There is no functional difference; they are aliases for each other."
    ],
    "correct_answer_index": 1,
    "explanation": "The goal of `__repr__` is to be unambiguous and ideally allow object recreation (e.g., `eval(repr(obj)) == obj`). The goal of `__str__` is to be readable. `print()` and `str()` will use `__str__` if available, otherwise they fall back to `__repr__`.",
    "has_latex": false,
    "difficulty_score": 3.0
  },
  {
    "question_text": "If a class only defines `__repr__` and not `__str__`, what happens when you call `print(obj)`?",
    "options": [
      "It raises a `TypeError`.",
      "It prints the object's memory address.",
      "It calls the `__repr__` method as a fallback.",
      "It prints a blank line."
    ],
    "correct_answer_index": 2,
    "explanation": "When `print()` or `str()` is used on an object, Python first looks for a `__str__` method. If one is not found, it falls back to using the `__repr__` method instead.",
    "has_latex": false,
    "difficulty_score": 2.16
  },
  {
    "question_text": "To enable the use of the `+` operator on instances of a custom class, which special method must be implemented?",
    "options": [
      "`__add__`",
      "`__plus__`",
      "`__sum__`",
      "`__concat__`"
    ],
    "correct_answer_index": 0,
    "explanation": "Implementing the `__add__(self, other)` method allows the `+` operator to be used with instances of your class. This is a form of operator overloading.",
    "has_latex": false,
    "difficulty_score": 1.5
  },
  {
    "question_text": "What will be the output of the following code?\\n```python\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nv1 = Vector(2, 4)\nv2 = Vector(3, 5)\nprint(v1 + v2)\n```",
    "options": [
      "Vector(5, 9)",
      "An error because you cannot add objects",
      "(5, 9)",
      "The memory address of a new Vector object"
    ],
    "correct_answer_index": 0,
    "explanation": "The expression `v1 + v2` calls the `v1.__add__(v2)` method. This method creates and returns a new `Vector` instance with coordinates `(2+3, 4+5)`. When this new object is printed, its `__repr__` method is called, producing the output 'Vector(5, 9)'.",
    "has_latex": true,
    "difficulty_score": 2.7
  },
  {
    "question_text": "Which special method allows an object's instances to be called as if they were functions?",
    "options": [
      "`__call__`",
      "`__invoke__`",
      "`__function__`",
      "`__run__`"
    ],
    "correct_answer_index": 0,
    "explanation": "If a class implements the `__call__(self, *args, **kwargs)` method, its instances can be invoked using parentheses, e.g., `my_object()`.",
    "has_latex": false,
    "difficulty_score": 1.5
  },
  {
    "question_text": "Which of these is NOT one of the four core principles of Object-Oriented Programming?",
    "options": [
      "Inheritance",
      "Encapsulation",
      "Recursion",
      "Polymorphism"
    ],
    "correct_answer_index": 2,
    "explanation": "The four main pillars of OOP are typically considered to be Inheritance, Encapsulation, Polymorphism, and Abstraction. Recursion is a general programming concept, not specific to OOP.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "True or False: A class can have multiple `__init__` methods.",
    "options": [
      "True",
      "False"
    ],
    "correct_answer_index": 1,
    "explanation": "False. Python does not support traditional method overloading. If you define a method with the same name twice in a class, the second definition will simply overwrite the first.",
    "has_latex": false,
    "difficulty_score": 1.44
  },
  {
    "question_text": "How can you simulate method overloading in Python for a constructor?",
    "options": [
      "By defining multiple `__init__` methods with different names.",
      "By using default arguments or `*args` and `**kwargs` in a single `__init__` method.",
      "By using the `@overload` decorator.",
      "It is not possible to simulate method overloading in Python."
    ],
    "correct_answer_index": 1,
    "explanation": "You can achieve a similar effect to overloading by defining a single method with optional parameters (default arguments) or a variable number of arguments (`*args`, `**kwargs`) and then checking the arguments to determine the behavior.",
    "has_latex": false,
    "difficulty_score": 2.4
  },
  {
    "question_text": "Which of the following is correct with respect to the OOP concept in Python?",
    "options": [
      "Objects are real world entities while classes are not real.",
      "Classes are real world entities while objects are not real.",
      "Both objects and classes are real world entities.",
      "Both object and classes are not real."
    ],
    "correct_answer_index": 0,
    "explanation": "An object is an instance of a class that represents a real-world entity, while a class is a blueprint or template from which objects are created.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "What will be the output of the following Python code snippet?\\n```python\nclass A:\n    def __init__(self, count=100):\n        self.count = count\n\nobj1 = A()\nobj2 = A(102)\n\nprint(obj1.count)\nprint(obj2.count)\n```",
    "options": [
      "100, 100",
      "100, 102",
      "102, 102",
      "Error"
    ],
    "correct_answer_index": 1,
    "explanation": "For `obj1`, the `__init__` method is called without an argument, so the default value of `count` (100) is used. For `obj2`, `102` is passed as an argument, overriding the default value.",
    "has_latex": true,
    "difficulty_score": 2.16
  },
  {
    "question_text": "Which of the following is correct regarding the memory IDs of the two objects created below?\\n```python\nclass A:\n    def __init__(self, name):\n        self.name = name\n\na1 = A(\"john\")\na2 = A(\"john\")\n```",
    "options": [
      "`id(a1)` and `id(a2)` will have the same value.",
      "`id(a1)` and `id(a2)` will have different values.",
      "Two objects with the same value of an attribute cannot be created.",
      "None of the above"
    ],
    "correct_answer_index": 1,
    "explanation": "Creating two separate instances of a class (`a1` and `a2`) results in two distinct objects in memory, even if their attributes have the same value. The `id()` function returns the unique identity of an object, which will be different for each instance.",
    "has_latex": true,
    "difficulty_score": 1.73
  },
  {
    "question_text": "What will be the output of the following code?\\n```python\nclass Book:\n    def __init__(self, author):\n        self.author = author\n\nbook1 = Book(\"V.M.Shah\")\nbook2 = book1\n\nprint(id(book1) == id(book2))\n```",
    "options": [
      "True",
      "False",
      "It will throw an error as multiple references to the same object are not possible.",
      "None of the above"
    ],
    "correct_answer_index": 0,
    "explanation": "The line `book2 = book1` does not create a new object. Instead, it makes the `book2` variable a reference to the same object that `book1` refers to. Therefore, both variables point to the same object in memory, and their IDs will be identical.",
    "has_latex": true,
    "difficulty_score": 1.8
  },
  {
    "question_text": "In Python, what is a method inside a class?",
    "options": [
      "attribute",
      "object",
      "argument",
      "function"
    ],
    "correct_answer_index": 3,
    "explanation": "A method is a function that belongs to a class and is defined within it. It describes the behavior of objects created from that class.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "What will be the output of the below Python code?\\n```python\nclass A:\n    num = 3\n    def __init__(self, num):\n        self.num = num\n\n    def change(self):\n        self.num = 7\n\na = A(5)\nprint(a.num)\na.change()\nprint(a.num)\n```",
    "options": [
      "5, 7",
      "5, 5",
      "3, 3",
      "3, 7"
    ],
    "correct_answer_index": 0,
    "explanation": "When `a = A(5)` is executed, the `__init__` method sets the instance variable `self.num` to `5`, which shadows the class variable `num`. The first print then outputs `5`. When `a.change()` is called, it reassigns the instance variable `self.num` to `7`. The second print then outputs `7`.",
    "has_latex": true,
    "difficulty_score": 2.59
  },
  {
    "question_text": "All classes have a function called _______, which is always executed when the class is being initiated.",
    "options": [
      "`init`",
      "`_init_()`",
      "`__init__`",
      "`init()`"
    ],
    "correct_answer_index": 2,
    "explanation": "The `__init__` method is the constructor in Python. It's automatically called when a new object of the class is created. While not mandatory to define explicitly, every class has an `__init__` method.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "You can delete properties on objects by using the ________ keyword.",
    "options": [
      "`delete`",
      "`dedl`",
      "`del`",
      "`drop`"
    ],
    "correct_answer_index": 2,
    "explanation": "The `del` keyword in Python is used to delete objects, including properties of a class instance.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "A variable that is defined inside a method and belongs only to the current instance of a class is known as an:",
    "options": [
      "Inheritance",
      "Instance variable",
      "Function overloading",
      "Instantiation"
    ],
    "correct_answer_index": 1,
    "explanation": "An instance variable is a variable defined within a class method using the `self` keyword. Each instance of the class has its own copy of the instance variables.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "What is `setattr()` used for?",
    "options": [
      "To set the value of an attribute.",
      "To access the attribute of the object.",
      "To check if an attribute exists or not.",
      "To delete an attribute."
    ],
    "correct_answer_index": 0,
    "explanation": "The `setattr()` built-in function is used to set the value of an attribute of an object. Its syntax is `setattr(object, name, value)`.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "What will be the output for the following code?\\n```python\nclass test:\n    def __init__(self, a):\n        self.a = a\n    def display(self):\n        print(self.a)\n\nobj = test()\nobj.display()\n```",
    "options": [
      "Runs normally, doesn't display anything",
      "Displays 0, which is the automatic default value",
      "Error as one argument is required while creating the object",
      "Error as display function requires an additional argument"
    ],
    "correct_answer_index": 2,
    "explanation": "The `__init__` method is defined to accept one positional argument (`a`) in addition to `self`. When the object `obj = test()` is created, no argument is passed, which results in a `TypeError`.",
    "has_latex": true,
    "difficulty_score": 2.16
  },
  {
    "question_text": "A class's documentation string (docstring) can be accessed via:",
    "options": [
      "`ClassName`",
      "`ClassName_doc_`",
      "`_doc_`",
      "`ClassName.__doc__`"
    ],
    "correct_answer_index": 3,
    "explanation": "The documentation string (docstring) for a class can be accessed using the special attribute `__doc__`. The correct way to access it is by using the class name followed by `.__doc__`.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "When a child class inherits from only one parent class, it is called:",
    "options": [
      "Single inheritance",
      "Singular inheritance",
      "Multiple inheritance",
      "Multilevel inheritance"
    ],
    "correct_answer_index": 0,
    "explanation": "Single inheritance is a type of inheritance where a class inherits from a single parent class.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "A parent class is the class being inherited from, also called a:",
    "options": [
      "derived class",
      "child class",
      "hybrid class",
      "base class"
    ],
    "correct_answer_index": 3,
    "explanation": "In inheritance, the parent class is also known as the base class or superclass. The child class is also known as the derived class or subclass.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "True or False: The child's `__init__()` function overrides the inheritance of the parent's `__init__()` function.",
    "options": [
      "True",
      "False"
    ],
    "correct_answer_index": 0,
    "explanation": "When a child class defines its own `__init__` method, it overrides the parent class's `__init__` method. The parent's constructor is no longer automatically called unless explicitly invoked with `super()`.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "What is the name of the function that allows a child class to inherit all the methods and properties from its parent?",
    "options": [
      "`self`",
      "`__init__()`",
      "`super()`",
      "`pass`"
    ],
    "correct_answer_index": 2,
    "explanation": "The `super()` function allows you to call a method from the parent class. Using `super().__init__()` in the child class's constructor ensures that the parent's `__init__` method is executed.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "Suppose B is a subclass of A. To invoke the `__init__` method in A from B, which line of code should you write?",
    "options": [
      "`A.__init__(self)`",
      "`B.__init__(self)`",
      "`A.__init__(B)`",
      "`B.__init__(A)`"
    ],
    "correct_answer_index": 0,
    "explanation": "To explicitly call the parent class's `__init__` method from the child class, you can use the syntax `ParentClass.__init__(self, arguments)`. Another common way is `super().__init__(arguments)`.",
    "has_latex": false,
    "difficulty_score": 1.44
  },
  {
    "question_text": "Which of the following statements is false?",
    "options": [
      "A non-private method in a superclass can be overridden.",
      "A derived class is a specialized version of a superclass.",
      "The value of a private variable in a superclass cannot be directly changed in the subclass.",
      "When a subclass defines its own constructor, the constructor of the superclass is automatically invoked first."
    ],
    "correct_answer_index": 3,
    "explanation": "This statement is false. If a subclass defines its own constructor (`__init__`), it overrides the superclass's constructor. To call the superclass's constructor, you must explicitly do so using `super().__init__()`.",
    "has_latex": false,
    "difficulty_score": 2.25
  },
  {
    "question_text": "What will be the output of the following code?\\n```python\nclass A:\n    def __init__(self, x=1):\n        self.x = x\n\nclass der(A):\n    def __init__(self, y=2):\n        super().__init__()\n        self.y = y\n\nobj = der()\nprint(obj.x, obj.y)\n```",
    "options": [
      "Error, the syntax of the invoking method is wrong",
      "The program runs fine but nothing is printed",
      "1 0",
      "1 2"
    ],
    "correct_answer_index": 3,
    "explanation": "When `obj = der()` is called, the `der` class's `__init__` is invoked. It calls `super().__init__()`, which runs the `A` class's `__init__`, setting `self.x` to its default value of 1. Then, the `der` class's `__init__` sets `self.y` to its default value of 2. Finally, it prints `1 2`.",
    "has_latex": true,
    "difficulty_score": 2.59
  },
  {
    "question_text": "What are methods that begin and end with two underscore characters called?",
    "options": [
      "Special methods",
      "In-built methods",
      "User-defined methods",
      "Private methods"
    ],
    "correct_answer_index": 0,
    "explanation": "Methods that have double underscores at the beginning and end, such as `__init__` or `__str__`, are known as special methods or 'dunder' methods.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "Which statement is wrong about inheritance?",
    "options": [
      "Protected members of a class can be inherited.",
      "The inheriting class is called a subclass.",
      "Private members of a class can be inherited and directly accessed.",
      "Inheritance is one of the features of OOP."
    ],
    "correct_answer_index": 2,
    "explanation": "Private members (those with two leading underscores) are name-mangled and cannot be directly accessed by subclasses. They are not designed to be inherited in a straightforward way.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "What is Instantiation in OOP terminology?",
    "options": [
      "Deleting an instance of a class.",
      "Modifying an instance of a class.",
      "Copying an instance of a class.",
      "Creating an instance of a class."
    ],
    "correct_answer_index": 3,
    "explanation": "Instantiation is the process of creating a new object (an instance) from a class blueprint.",
    "has_latex": false,
    "difficulty_score": 1.0
  },
  {
    "question_text": "What will be the output of the following Python code?\\n```python\nclass test:\n    def __init__(self, a=\"Hello World\"):\n        self.a = a\n    def display(self):\n        print(self.a)\n\nobj = test()\nobj.display()\n```",
    "options": [
      "The program has an error because constructors can't have default arguments.",
      "Nothing is displayed.",
      "\"Hello World\" is displayed.",
      "The program has an error because the display function doesn't have parameters."
    ],
    "correct_answer_index": 2,
    "explanation": "The `__init__` method has a default argument `a=\"Hello World\"`. When `obj=test()` is called without an argument, the default value is used. The `display()` method then prints the value of `self.a`.",
    "has_latex": true,
    "difficulty_score": 2.16
  },
  {
    "question_text": "What type of inheritance is illustrated in the following Python code?\\n```python\nclass A:\n    pass\nclass B(A):\n    pass\nclass C(B):\n    pass\n```",
    "options": [
      "Multi-level inheritance",
      "Multiple inheritance",
      "Hierarchical inheritance",
      "Single inheritance"
    ],
    "correct_answer_index": 0,
    "explanation": "This is an example of multi-level inheritance, where a class (B) inherits from a parent class (A), and another class (C) inherits from that child class (B), forming a chain.",
    "has_latex": true,
    "difficulty_score": 1.44
  },
  {
    "question_text": "What is the biggest reason for the use of polymorphism?",
    "options": [
      "It allows the programmer to think at a more abstract level.",
      "There is less program code to write.",
      "The program will have a more elegant design and will be easier to maintain and update.",
      "Program code takes up less space."
    ],
    "correct_answer_index": 2,
    "explanation": "Polymorphism allows for flexible and decoupled code. A single function can handle objects of many different classes, which makes the overall design cleaner and easier to extend without modifying existing code.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "What's the difference between class attributes and instance attributes?",
    "options": [
      "Class attributes are always strings, but instance attributes can be any data type.",
      "Class attributes have the same value for all class instances, but instance attributes can have different values for each instance.",
      "There is no difference.",
      "Class attributes are defined with `cls` and instance attributes with `self`."
    ],
    "correct_answer_index": 1,
    "explanation": "Class attributes are shared by all instances of a class, meaning a change to the attribute on the class reflects in all instances. Instance attributes are unique to each object and are defined within the `__init__` method using `self`.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "Which of the following is true about `_protected` class members?",
    "options": [
      "They begin with two underscores.",
      "They cannot be accessed by subclasses.",
      "They can be accessed by a name mangling method.",
      "They are a convention to discourage external use but can still be accessed."
    ],
    "correct_answer_index": 3,
    "explanation": "Protected members, prefixed with a single underscore, are a convention in Python to indicate they are for internal use. They are not enforced by the interpreter and can still be accessed from outside the class, unlike private members.",
    "has_latex": false,
    "difficulty_score": 1.8
  },
  {
    "question_text": "The method that makes an object behave like an iterator is `__iter__` and it must return an iterator.",
    "options": [
      "True",
      "False"
    ],
    "correct_answer_index": 0,
    "explanation": "To make a class's objects iterable, you must implement the `__iter__` special method, which should return an iterator object (an object that has a `__next__` method).",
    "has_latex": false,
    "difficulty_score": 1.5
  },
  {
    "question_text": "If a subclass provides a specific implementation of a method that is already defined in the base class, it is called method overriding.",
    "options": [
      "True",
      "False"
    ],
    "correct_answer_index": 0,
    "explanation": "Method overriding is a key feature of inheritance where a child class can provide its own implementation for a method that it inherited from its parent class.",
    "has_latex": false,
    "difficulty_score": 1.2
  },
  {
    "question_text": "What is the purpose of the `__repr__` method in a class?",
    "options": [
      "It provides an official string representation of an object, mainly for developers.",
      "It provides an informal, human-readable string representation for end-users.",
      "It is used to compare two objects for equality.",
      "It is used to get the length of an object."
    ],
    "correct_answer_index": 0,
    "explanation": "The `__repr__` method's goal is to be unambiguous and provide a string that, if passed to `eval()`, would ideally recreate the object. It's primarily used for debugging and development.",
    "has_latex": false,
    "difficulty_score": 1.44
  },
  {
    "question_text": "What is the purpose of the `__getitem__` method in a class?",
    "options": [
      "To get a value from a dictionary.",
      "To make a class iterable.",
      "To allow objects to use indexing and slicing, like `obj[key]`.",
      "To get an item from a list."
    ],
    "correct_answer_index": 2,
    "explanation": "The `__getitem__` method is part of Python's container protocol. Implementing it allows an object to be accessed using square bracket notation, similar to lists and dictionaries.",
    "has_latex": false,
    "difficulty_score": 1.5
  }
]